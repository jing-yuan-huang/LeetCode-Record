21. Best Time to Buy and Sell Stock
    問題設定：

給定一個價格數組，你只能買入一次並賣出一次，計算能獲得的最大利潤。

目標是找到買入和賣出之間的最大差值。

解法：

這個題目可以通過「維持一個範圍」來解決：遍歷價格數組，保持一個最小價格 min_price，每次遍歷一個新的價格時，計算從這個 min_price 賣出能獲得的利潤。然後更新最大利潤 max_profit。

時間複雜度：

O(n)，其中 n 是價格數組的長度。我們只需要遍歷數組一次，並且每次都只做簡單的比較和更新。

為什麼相對簡單：

這個問題的邏輯非常簡單，維持的範圍只有一個變量 min_price，並且在遍歷過程中對每個價格進行一次更新，計算一次最大利潤。這使得它的解法很高效，時間複雜度是線性時間 O(n)。

2. 3. Longest Substring Without Repeating Characters
      問題設定：

給定一個字符串，要求找出其中最長的子串，並且該子串中的字符不能重複。

解法：

這個題目也可以用「維持一個範圍」來解決。通常會使用「滑動窗口」方法：用兩個指標 start 和 end 定義一個窗口，並且根據窗口內的字符情況動態調整 start 和 end 的位置，從而獲得最大無重複字符的子串。

具體步驟：

用 end 來擴展窗口，直到遇到重複字符。

一旦遇到重複字符，調整 start 指標，縮小窗口，直到去除重複字符。

確保每次都計算窗口的長度，並更新最大長度。

時間複雜度：

O(n)，其中 n 是字符串的長度。每個字符只會被 start 和 end 指標訪問一次，因此是線性時間複雜度。

為什麼比「Best Time to Buy and Sell Stock」複雜：

儘管都用滑動窗口，但這個題目涉及到的是「窗口內的字符是否重複」，需要管理和查找子串中字符的唯一性。對比股票買賣的問題，這需要使用資料結構（如哈希集合或哈希表）來記錄字符是否重複，這使得這個問題的邏輯稍微複雜一些。

3. 76. Minimum Window Substring
       問題設定：

給定兩個字符串 s 和 t，要求找出 s 中最短的子串，該子串包含了 t 中的所有字符。

解法：

這個題目也使用了滑動窗口的方法，但它的難度較高，因為我們需要確保子串不僅包含 t 中的所有字符，還需要處理字符的頻次。

使用兩個指標 start 和 end 來定義窗口，並且需要維護兩個計數器：

t_count：記錄 t 中各字符的需求頻次。

window_count：記錄窗口中字符的實際頻次。

具體步驟：

用 end 指標擴展窗口，直到窗口包含 t 中所有字符（根據字符頻次來檢查）。

當窗口內已經包含了所有字符時，縮小 start 指標來縮小窗口，並嘗試找到更小的有效子串。

時間複雜度：

O(n)，其中 n 是字符串 s 的長度。和「Longest Substring Without Repeating Characters」一樣，start 和 end 只會遍歷一次整個字符串。

為什麼比前兩者更複雜：

雖然時間複雜度和「Longest Substring Without Repeating Characters」相同，但這個題目需要處理字符頻次，並且在滑動窗口內不僅僅是檢查字符是否重複，而是需要確認是否所有字符都出現了足夠的次數。這增加了邏輯的複雜度。

需要額外的資料結構來管理字符的頻次（比如哈希表），並且需要處理的邏輯更多。

比較： 121. Best Time to Buy and Sell Stock：只需要維持一個範圍（最小價格），計算一次賣出價格與當前最小價格的差值，問題的邏輯比較簡單，適合用一個變量來維持範圍。

3. Longest Substring Without Repeating Characters：這個問題需要維持一個範圍來確保子串無重複，並且在滑動窗口內進行動態調整。相比「Best Time to Buy」，這涉及更多的字符處理和查詢，所以稍微複雜。

4. Minimum Window Substring：這個問題更進一步，需要考慮字符的頻次，維持兩個範圍（窗口的實際字符和目標字符的頻次）並且進行動態調整。需要額外的資料結構（哈希表）來處理字符頻次的匹配，這使得問題的邏輯更加複雜。
